"""
OFI Engine Wrapper

This module provides a Python interface to the Rust-based OFI analysis engine.
"""

import os
import sys
from typing import Dict, Any, Optional
from dataclasses import dataclass

# Try to import the Rust module
try:
    import ofi_engine_rust
    from ofi_engine_rust import OFIEngine as RustOFIEngine  # type: ignore
    
    # Check if the module was imported successfully
    _RUST_ENGINE_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Could not import Rust OFI engine: {e}")
    _RUST_ENGINE_AVAILABLE = False
    ofi_engine_rust = None
    RustOFIEngine = None

@dataclass
class TradingSignal:
    """Represents a trading signal generated by the OFI engine"""
    symbol: str
    signal_type: str
    price: float
    confidence: float
    timestamp: str
    reason: str
    
    @classmethod
    def from_rust(cls, rust_signal: Any) -> 'TradingSignal':
        """Create a TradingSignal from a PyO3 object"""
        return cls(
            symbol=rust_signal.symbol,
            signal_type=rust_signal.signal_type,
            price=rust_signal.price,
            confidence=rust_signal.confidence,
            timestamp=rust_signal.timestamp,
            reason=rust_signal.reason
        )

class OFIEngine:
    """Main OFI analysis engine wrapper"""
    
    def __init__(self, api_key: str = "", secret_key: str = "", passphrase: str = ""):
        """Initialize the OFI engine"""
        self._rust_engine = None
        if _RUST_ENGINE_AVAILABLE and RustOFIEngine is not None:
            try:
                # Check if OFIEngine class exists in the module
                self._rust_engine = RustOFIEngine(api_key, secret_key, passphrase)
            except Exception as e:
                print(f"Warning: Could not initialize Rust OFI engine: {e}")
                self._rust_engine = None
        else:
            print("Warning: Rust OFI engine not available, using placeholder implementation")
    
    def analyze_symbol(self, symbol: str, imbalance_ratio: float = 3.0, 
                      analysis_duration_ms: int = 5000, delta_threshold: float = 50000.0,
                      lookback_period_ms: int = 5000) -> Optional[TradingSignal]:
        """Analyze a symbol. Returns a TradingSignal object or None if no signal is found."""
        if self._rust_engine is not None:
            try:
                # Call the Rust function (renamed to analyze_symbol_py in Rust)
                rust_signal = self._rust_engine.analyze_symbol(
                    symbol, imbalance_ratio, analysis_duration_ms, delta_threshold, lookback_period_ms
                )
                
                # If Rust returns None, we also return None
                if rust_signal is None:
                    return None
                    
                # Convert the Rust object to a Python dataclass
                return TradingSignal.from_rust(rust_signal)
            except Exception as e:
                print(f"Error analyzing symbol '{symbol}' with Rust engine: {e}")
                # Return None on error to avoid crashing the screener
                return None
        
        # Placeholder implementation
        print("Warning: Rust engine not available, returning no signal")
        return None
    
    def get_order_book(self, symbol: str) -> Dict[str, float]:
        """Get current order book for a symbol"""
        if self._rust_engine is not None:
            try:
                return self._rust_engine.get_order_book(symbol)
            except Exception as e:
                print(f"Error getting order book with Rust engine: {e}")
                # Fall back to placeholder implementation
                pass
        
        # Placeholder implementation
        return {"bids": 0.0, "asks": 0.0}
    
    def get_engine_info(self) -> str:
        """Get engine information"""
        if self._rust_engine is not None:
            try:
                return self._rust_engine.get_engine_info()
            except Exception as e:
                print(f"Error getting engine info with Rust engine: {e}")
                # Fall back to placeholder implementation
                pass
        
        # Placeholder implementation
        return "OFI Engine (Python Placeholder)"
    
    @property
    def is_available(self) -> bool:
        """Check if the Rust engine is available"""
        return self._rust_engine is not None

# Create a default engine instance
_default_engine: Optional[OFIEngine] = None

def get_default_engine() -> OFIEngine:
    """Get the default OFI engine instance"""
    global _default_engine
    if _default_engine is None:
        # Try to initialize with environment variables
        api_key = os.getenv("BITGET_API_KEY", "")
        secret_key = os.getenv("BITGET_SECRET_KEY", "")
        passphrase = os.getenv("BITGET_PASSPHRASE", "")
        _default_engine = OFIEngine(api_key, secret_key, passphrase)
    return _default_engine

def analyze_symbol(symbol: str, imbalance_ratio: float = 3.0, 
                  analysis_duration_ms: int = 5000) -> Optional[TradingSignal]:
    """Analyze a symbol for trading signals using the default OFI engine"""
    engine = get_default_engine()
    return engine.analyze_symbol(symbol, imbalance_ratio, analysis_duration_ms)

def get_order_book(symbol: str) -> Dict[str, float]:
    """Get current order book for a symbol using the default OFI engine"""
    engine = get_default_engine()
    return engine.get_order_book(symbol)